2316

image file formats: 
 compressed / uncompressed
 compressed:
  - smaller
  - .png .jpg .gif 
 uncompressed:
  - no degredation 
  - raw pixel information
  - .tiff .bmp .raw 

 lossy / lossless
 lossy:
  - loses original information
  - .jpg
 lossless:
  - retains all of the data
  - .tiff .bmp .raw .png

raster / vector
 raster:
  - cannot be scaled up well
  - defined by a grid of pixels
 vector:
  - list of shapes in the image (list of instructions)
run-length encoding:
 bbbbbrrryyyy
 5b3r4y 


netpbm 
 - uncompressed 
 - lossless 
 - large files (.ppm)


2416

netpbm
 -- ascii values
 P3 <X-RES> <Y-RES> <MAX_COLOR_VALUE>
 raster data through < #R #G #B >  
 all white space is equivalent 

 ctrl c ctrl c (switch to and from image in ppm file)
 
 0, 0 is upper left
 
2516

bresenharn's line algorithm:
y = mx+b
y = \y / \x x + b
y\x = x\y + b\x
0 = x\y - y\x + b\x
A = \y
B = -\x
C = b\x

0 = Ax + By + C
f(x,y) = Ax+ By+C = 0 ( x,y) is on the line
< 0 (x,y) is above the line
> 0 (x,y) is below the line

1 (x+1, y)
2 (x+1, y+1)
midpoint (x+1, y+1/2)

f(x+1, y + 1/2) = 0 midpoint is on the line, either point is okay
<0 midpoint is above line -> draw (x+1, y)
>0 midpoint is below line -> draw (x+1, y+1)

2916

bresenham's line algorithm:
A = \y 
B = -\x 
C = (\x)b

1. (x+1, y)
2. (x+1, y+1)
3. (midpoint) --> (x+1, y+1/2)

first draft algorithm

//(x0, y0) -> (x1, y1)


x = x0 , y = y0
while x <= x1: //x is always incremented
 //draw (x,y)
 d = f(x+1,y+1/2)
 if(d > 0){
  y += 1
 }
 x += 1


initial value of d

d = f(x0 + 1, y0 + 1/2)
d = A(x0 + 1) + B(y0 + 1/2) + C

d = Ax0 + A + By0 + B/2 + C

d = Ax0 + By0 + C     + A + B/2
d = 0 + A + B/2

d = A + B/2



2nd draft algorithm:
d = A + B/2
while x < x1: 
 plot(x,y)
 if d > 0:
  y += 1
 x += 1
 d = f(x+1, y+1/2)

*** if d > 0

x -> x+1 
y -> y+1

d=f(x+1,y+1)
d=A(x+1) + B(y+1) + C
d = Ax + A + By + B + C
d = Ax + By + C + A + B
Ax + By + C = f(x,y) --> previous point's d

d = d + A + B



*** if d < 0
x -> x + 1 y -> y
d = f(x+1, y)
d = A(x+1) + By +C
d = Ax + By + C + A

d = d + A

3rd draft:

d = A + B/2
while(x <= x1)
 plot (x,y)
 if(d> 0)
  y += 1
  d += B
 x+=1
 d+=A
     
21016

d = A + B/2 --> D = 2A + B
d = d + A --> D = D + 2A
d = d + A + B --> D = D + 2A + 2B
A = y1 - y0
B = -(x1 - x0)
d = 2A + B 
while (x <= x1):
 plot(x,y)
 if(d>0)
  y += 1
  d +=2B
 x +=1
 d +=2A

OCTANT II:

m > 1
possible pixels: (x, y+1), (x+1, y+1)
midpoint: (x+1/2, y+1)

if f(x,y) < 0, (x,y) is to the left
if f(x,y) > 0, (x,y) is to the right

test:
if d > 0, draw (x, y+1)
if d < 0, draw (x+1,y+1)


if d<0:
   d= d+A+B
if d>0:
   d = d + B

algorithm changes:

d = A + 2B

while(y<=y1)
 plot(x,y)
 if(d< 0)
  x+=1
  d+=2A
 y+= 1
 d+=2B

assume every line goes from left to right

OCTANT VIII:
-1 < m < 0 
possible points: 
(x+1, y-1)
(x+1, y)

22216

using matrices
point matrix[p0 p1 p2 p3 p4 p5]

(edge matrix)
while(i < points.length-2)
 draw_line(points[i], points[i+1]
 i+=2



shape matrix: matrix per shape
edge matrix: [p0 p1 p1 p2 p2 p0 p3 p4]
vertex matrix: [p0 p1 p2], [p1 p0 p2]


edge matrix: [p0 p1 p1 p2 p2 p0 p3 p4]
[
x0 x1 x1 x2
y0 y1 y1 y2 
z0 z1 z1 z2
]

edges = new_matrix
add_edge(edges, p0, p1); //prob multiple calls
draw_edges(edges)

22316

matrix math review:
- scalar multiplication
- matrix multiplcation
- multiplicitaive identity matrix

scalar multiplication:
s * [a b\c d] = [sa sb\sc sd]

matrix multiplication:
- not commutative
- m0 * m1 != m1 * m0
- # of columns in m0 = # rows in m1
[a b c] * [1\2\3] = [1a + 2b + 3c]

dimensions: 
1 x 3  * 3 x 1 = 1 x 1  
A x B * B x C = A x C

[1 2 3 \ 4 5 6] * [10 40 \ 20 50 \ 30 60] = [1(10) + 2(20) + 3(30) 1(40) + 2(50)+ 3(60)\4(10)+....]

multiplicative identity
-always square
-diagonal of 1's
-0's everywher eelse

[1 0 0 0\0 1 0 0\0 0 1 0\0 0 0 1] * [a e \ b f \ c g \ d h]  = [a e \ b f \ c g \ d h]

[a e \ b f \ c g \ d h] * [1 0\ 0 1] = same


matrices in graphics:
scaling -- with respect to the origin
(x,y,z) --s(a,b,c)--> (ax, by, cz);
[a 0 0 0\0 b 0 0\0 0 c 0\0 0 0 d] * [x\y\z\1] = [zx\by\cz\1]


22416

transformation matrices

scaling(from yesterday)

translating: (x,y,z) --t(a,b,c)--> (a+x,b+y,c+z)

[1 0 0 a\0 1 0 b\0 0 1 c\ 0 0 0 1] * [x\y\z\1] = [a+x\b+y\c+z\1] 

rotating: (x,y,z) --r_z-axisT--> (?,?,z)

polar coordinate: 
x = r cos phi, y = r sin phi
xr = r cos(phi + theta) = r cos(phi) cos(theta) - rsin(theta)sin(phi) = xcos (theta) - y sin (theta) 
yr = r sin(phi + theta)

rotating: (x,y,z) --r_zaxisT--> (xcos(theta)-ysin(theta), ycos(theta) + xsin(theta),z)

[cos(theat) -sin(theta) 0 0\
sin(theta) cos(theta) 0 0\
0 0 1 0\
0 0 0 1]
*
[x\y\z\1]
=
[xcos(theta)-ysin(theta)\ycos(theta)+xsin(theta)\z\1]

22516

(x,y,z) --Rx,theta--> (x, ycos(theta)-zsin(theta), ysin(theta)+zcos(theta))
[1 0 0 0\
0 cos(theta) -sin(theta) 0\
0 sin(theta) cos(theta) 0\
0 0 0 1]

(x,y,z) --Ry,theta--> (xcos(theta)-zsin(theta), y, xsin(theta)+zcos(theta))

[cos(theta) 0 -sin(theta) 0\
0 1 0 0\
sin(theta) 0 cos(theta) 0\
0 0 0 1]


Applying Transformations:

E0 : edge matrix 
T: translation matrix
S: scale matrix
R: rotation matrix

T * E0 = E1: translated
S * E1 = E2: translated -> scaled
R * E2 = E3: translated -> scaled -> rotated

More efficient:
E3 = R * S * T * E0

3716

parametric equation:
x = f(t)
y = g(t)

line(x0,y0) -> (x1,y1)
f(x) = x0 + t(\x)
g(y) = y0 + t(\y)

t: 0 -> 1

example (circle)
double param_x(double t){
 return 100 * cos(2*M_PI * t) + 250;

}

double param_y(double t){
 return 100 *sin(2*M_PI*t) + 250;

}


make circle:
x = r cos(theta) + cx
y = r sin(theta) + cy

3816
Hermite curve:
inputs:
 p0, p1: endpoints
 r0, r1: rate of change at each endopint

hermite curves:
h1(t) = 2t^3 - 3t^2 + 1
h2(t) = 2t^3 - 3t^2
h3(t) = t^3 - 2t^2 + t
h4(t) = t^3 - t^2

cubic curve:
fx(t) = at^3 + bt^2 + ct + d: points on the curve
f'(t) = 3at^2 + 2bt + c: rates of change(slopes)

when t = 0: 
 f(t) = d : p0
 f'(t) = c : r0
t = 1: 
 f(t) = a + b + c + d = p1
 f'(t) = 3a + 2b + c = r1

3916
hermite curves: 

(M)[0 0 0 1\1 1 1 1\ 0 0 1 0\ 3 2 1 0] * (C)[a\b\c\d] = (G)[d \ a+b+c+d\c\3a+2b] = [p0\p1\r0\r1]

M*C = G

M^-1 * M * C = M^-1 * G
I * C = M^-1 * G
C = M^-1 * G

multiplicative inverse =
[2 -2 1 1\ -3 3 -2 -1\ 0 0 1 0\1 0 0 0]

hermite curves:

[t^3\t^2\t\1] * multiplicative inverse ^ = [2t^3 - 3t^2 + 1     -2t^3+ 3t^2    t^3-2t^2+ t    t^3 + t^2]

Bezier curves:
Inputs: [

32916
wirefram/polygon meshes
wireframe: 
-3d objects we defined as the edges that connect the vertices
-use existing code to add points to an edge matrix
-fast

polygon
-3d objects are defined by polygons(usually triangles or quadralaterals) that cover the surface of the object.
-3/4 points are used to define a polygon
-change from edge matrix -> polygon matrix
-help create solid objects & remove backfaces

polygon matrix
m = [p0 p1 p2, p0 p2 p3] 

EDGE V POLYGON
plot > plot
draw_line > draw_line
draw_lines > draw_polygons
add_point > add_point
add_edge > add_polygon * points must be added counterclockqise