2316

image file formats: 
 compressed / uncompressed
 compressed:
  - smaller
  - .png .jpg .gif 
 uncompressed:
  - no degredation 
  - raw pixel information
  - .tiff .bmp .raw 

 lossy / lossless
 lossy:
  - loses original information
  - .jpg
 lossless:
  - retains all of the data
  - .tiff .bmp .raw .png

raster / vector
 raster:
  - cannot be scaled up well
  - defined by a grid of pixels
 vector:
  - list of shapes in the image (list of instructions)
run-length encoding:
 bbbbbrrryyyy
 5b3r4y 


netpbm 
 - uncompressed 
 - lossless 
 - large files (.ppm)


2416

netpbm
 -- ascii values
 P3 <X-RES> <Y-RES> <MAX_COLOR_VALUE>
 raster data through < #R #G #B >  
 all white space is equivalent 

 ctrl c ctrl c (switch to and from image in ppm file)
 
 0, 0 is upper left
 
2516

bresenharn's line algorithm:
y = mx+b
y = \y / \x x + b
y\x = x\y + b\x
0 = x\y - y\x + b\x
A = \y
B = -\x
C = b\x

0 = Ax + By + C
f(x,y) = Ax+ By+C = 0 ( x,y) is on the line
< 0 (x,y) is above the line
> 0 (x,y) is below the line

1 (x+1, y)
2 (x+1, y+1)
midpoint (x+1, y+1/2)

f(x+1, y + 1/2) = 0 midpoint is on the line, either point is okay
<0 midpoint is above line -> draw (x+1, y)
>0 midpoint is below line -> draw (x+1, y+1)

2916

bresenham's line algorithm:
A = \y 
B = -\x 
C = (\x)b

1. (x+1, y)
2. (x+1, y+1)
3. (midpoint) --> (x+1, y+1/2)

first draft algorithm

//(x0, y0) -> (x1, y1)


x = x0 , y = y0
while x <= x1: //x is always incremented
 //draw (x,y)
 d = f(x+1,y+1/2)
 if(d > 0){
  y += 1
 }
 x += 1


initial value of d

d = f(x0 + 1, y0 + 1/2)
d = A(x0 + 1) + B(y0 + 1/2) + C

d = Ax0 + A + By0 + B/2 + C

d = Ax0 + By0 + C     + A + B/2
d = 0 + A + B/2

d = A + B/2



2nd draft algorithm:
d = A + B/2
while x < x1: 
 plot(x,y)
 if d > 0:
  y += 1
 x += 1
 d = f(x+1, y+1/2)

*** if d > 0

x -> x+1 
y -> y+1

d=f(x+1,y+1)
d=A(x+1) + B(y+1) + C
d = Ax + A + By + B + C
d = Ax + By + C + A + B
Ax + By + C = f(x,y) --> previous point's d

d = d + A + B



*** if d < 0
x -> x + 1 y -> y
d = f(x+1, y)
d = A(x+1) + By +C
d = Ax + By + C + A

d = d + A

3rd draft:

d = A + B/2
while(x <= x1)
 plot (x,y)
 if(d> 0)
  y += 1
  d += B
 x+=1
 d+=A
     
21016

d = A + B/2 --> D = 2A + B
d = d + A --> D = D + 2A
d = d + A + B --> D = D + 2A + 2B
A = y1 - y0
B = -(x1 - x0)
d = 2A + B 
while (x <= x1):
 plot(x,y)
 if(d>0)
  y += 1
  d +=2B
 x +=1
 d +=2A

OCTANT II:

m > 1
possible pixels: (x, y+1), (x+1, y+1)
midpoint: (x+1/2, y+1)

if f(x,y) < 0, (x,y) is to the left
if f(x,y) > 0, (x,y) is to the right

test:
if d > 0, draw (x, y+1)
if d < 0, draw (x+1,y+1)


if d<0:
   d= d+A+B
if d>0:
   d = d + B

algorithm changes:

d = A + 2B

while(y<=y1)
 plot(x,y)
 if(d< 0)
  x+=1
  d+=2A
 y+= 1
 d+=2B

assume every line goes from left to right

OCTANT VIII:
-1 < m < 0 
possible points: 
(x+1, y-1)
(x+1, y)

22216

using matrices
point matrix[p0 p1 p2 p3 p4 p5]

(edge matrix)
while(i < points.length-2)
 draw_line(points[i], points[i+1]
 i+=2



shape matrix: matrix per shape
edge matrix: [p0 p1 p1 p2 p2 p0 p3 p4]
vertex matrix: [p0 p1 p2], [p1 p0 p2]


edge matrix: [p0 p1 p1 p2 p2 p0 p3 p4]
[
x0 x1 x1 x2
y0 y1 y1 y2 
z0 z1 z1 z2
]

edges = new_matrix
add_edge(edges, p0, p1); //prob multiple calls
draw_edges(edges)

22316

matrix math review:
- scalar multiplication
- matrix multiplcation
- multiplicitaive identity matrix

scalar multiplication:
s * [a b\c d] = [sa sb\sc sd]

matrix multiplication:
- not commutative
- m0 * m1 != m1 * m0
- # of columns in m0 = # rows in m1
[a b c] * [1\2\3] = [1a + 2b + 3c]

dimensions: 
1 x 3  * 3 x 1 = 1 x 1  
A x B * B x C = A x C

[1 2 3 \ 4 5 6] * [10 40 \ 20 50 \ 30 60] = [1(10) + 2(20) + 3(30) 1(40) + 2(50)+ 3(60)\4(10)+....]

multiplicative identity
-always square
-diagonal of 1's
-0's everywher eelse

[1 0 0 0\0 1 0 0\0 0 1 0\0 0 0 1] * [a e \ b f \ c g \ d h]  = [a e \ b f \ c g \ d h]

[a e \ b f \ c g \ d h] * [1 0\ 0 1] = same


matrices in graphics:
scaling
(x,y,z) --s(a,b,c)--> (ax, by, cz);
[a 0 0 0\0 b 0 0\0 0 c 0\0 0 0 d] * [x\y\z\1] = [zx\by\cz\1]